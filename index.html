<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Codenix Demo - AI Coding Assistant</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://js.puter.com/v2/"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        :root {
            --activity-bar-bg: #333333;
            --sidebar-bg: #252526;
            --editor-bg: #1E1E1E;
            --header-bg: #3c3c3c;
            --statusbar-bg: #007ACC;
            --text-color: #CCCCCC;
            --border-color: #3c3c3c;
        }
        body {
            color: var(--text-color);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
        }
        .activity-bar { background-color: var(--activity-bar-bg); }
        .sidebar { background-color: var(--sidebar-bg); }
        .editor-group { background-color: var(--editor-bg); }
        .status-bar { background-color: var(--statusbar-bg); }
        .header { background-color: var(--header-bg); }
        .sidebar-view { display: none; }
        .sidebar-view.active { display: flex; }
        .activity-bar-icon {
            transition: background-color 0.2s ease-in-out;
        }
        .activity-bar-icon.active, .activity-bar-icon:hover {
            background-color: #525252;
        }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #2d2d2d; }
        ::-webkit-scrollbar-thumb { background: #555; }
        ::-webkit-scrollbar-thumb:hover { background: #777; }
        #preview-iframe {
            width: 100%;
            height: 100%;
            border: none;
            background-color: #fff;
        }
        .file-icon {
            width: 1.25rem;
            text-align: center;
            margin-right: 0.5rem;
        }
        .chat-plan-buttons button {
            transition: background-color 0.2s ease-in-out;
        }
        #code-editor::placeholder {
            color: #a0aec0;
        }
        /* Autocomplete styles */
        #autocomplete-box {
            position: absolute;
            border: 1px solid #4a5568;
            background-color: #2d3748;
            color: white;
            border-radius: 4px;
            z-index: 100;
            max-height: 150px;
            overflow-y: auto;
        }
        .autocomplete-item {
            padding: 4px 8px;
            cursor: pointer;
        }
        .autocomplete-item:hover, .autocomplete-item.selected {
            background-color: #4a5568;
        }
        .file-item.selected-file {
            background-color: #007ACC !important;
            color: white;
        }
    </style>
</head>
<body class="bg-editor-bg text-gray-300 h-screen">

    <div id="login-overlay" class="w-full h-full flex items-center justify-center bg-gray-900 bg-opacity-75 absolute z-50">
        <div class="text-center">
            <h1 class="text-4xl font-bold text-white mb-4">Welcome to Codenix Demo</h1>
            <p class="text-gray-400 mb-8">Please sign in to start coding with AI.</p>
            <button id="sign-in-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-lg">
                <i class="fas fa-sign-in-alt mr-2"></i>Sign In with Puter
            </button>
        </div>
    </div>

    <div id="main-app" class="flex h-full w-full" style="display: none;">
        <div class="activity-bar w-12 flex flex-col items-center py-4 space-y-4 flex-shrink-0">
            <div class="activity-bar-icon p-2 rounded cursor-pointer active" data-view="file-explorer-view"><i class="fas fa-files fa-lg" title="Explorer"></i></div>
            <div class="activity-bar-icon p-2 rounded cursor-pointer" data-view="chat-view"><i class="fas fa-comments fa-lg" title="AI Assistant"></i></div>
            <div class="activity-bar-icon p-2 rounded cursor-pointer" data-view="preview-view"><i class="fas fa-eye fa-lg" title="Preview"></i></div>
        </div>

        <div id="sidebar-container" class="sidebar w-64 flex-shrink-0">
            <div id="file-explorer-view" class="sidebar-view active p-4 h-full flex-col">
                <div id="explorer-header" class="pb-2 mb-2 border-b border-gray-700">
                    <h2 class="text-sm font-bold uppercase tracking-wider" id="username-display">Explorer</h2>
                </div>
                <div id="file-list" class="mb-4 flex-grow overflow-y-auto"></div>
                <input type="text" id="new-filename" class="bg-gray-700 text-white p-2 rounded w-full text-sm" placeholder="New file...">
                <button id="create-file-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded w-full mt-2 text-sm">Create File</button>
            </div>
            <div id="chat-view" class="sidebar-view p-4 h-full flex-col">
                <h2 class="text-sm font-bold uppercase tracking-wider mb-4">AI Assistant</h2>
                <div id="chat-history" class="flex-grow overflow-y-auto mb-4 p-2 bg-editor-bg rounded"></div>
                <div class="flex">
                    <input type="text" id="chat-input" class="bg-gray-700 text-white p-2 rounded-l w-full text-sm" placeholder="Ask AI...">
                    <button id="send-chat-btn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold p-2 rounded-r"><i class="fas fa-paper-plane"></i></button>
                </div>
            </div>
            <div id="preview-view" class="sidebar-view p-2 h-full w-full flex-col">
                <h2 class="text-sm font-bold uppercase tracking-wider m-2">Live Preview</h2>
                <iframe id="preview-iframe"></iframe>
            </div>
        </div>

        <div class="editor-group flex-grow flex flex-col relative">
            <header class="header h-12 flex-shrink-0 flex justify-between items-center px-4">
                <h1 class="text-lg font-bold">Codenix Demo</h1>
                <button id="publish-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold text-sm py-1 px-3 rounded"><i class="fas fa-rocket mr-1"></i>Publish</button>
            </header>
            <div id="editor-tabs" class="flex bg-sidebar-bg flex-shrink-0"></div>
            <textarea id="code-editor" class="flex-grow bg-white text-black p-4 font-mono text-base" placeholder="Select a file to start coding..."></textarea>
            <div id="autocomplete-box" style="display: none;"></div>
            <div id="status-bar" class="status-bar h-6 w-full flex-shrink-0 flex items-center justify-end px-4 text-xs">Ready</div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            try {
                const loginOverlay = document.getElementById('login-overlay');
                const signInBtn = document.getElementById('sign-in-btn');
                const mainApp = document.getElementById('main-app');
                const fileList = document.getElementById('file-list');
                const newFilenameInput = document.getElementById('new-filename');
                const createFileBtn = document.getElementById('create-file-btn');
                const codeEditor = document.getElementById('code-editor');
                const editorTabs = document.getElementById('editor-tabs');
                const chatHistory = document.getElementById('chat-history');
                const chatInput = document.getElementById('chat-input');
                const sendChatBtn = document.getElementById('send-chat-btn');
                const usernameDisplay = document.getElementById('username-display');
                const activityBarIcons = document.querySelectorAll('.activity-bar-icon');
                const sidebarViews = document.querySelectorAll('.sidebar-view');
                const previewIframe = document.getElementById('preview-iframe');
                const sidebarContainer = document.getElementById('sidebar-container');
                const publishBtn = document.getElementById('publish-btn');
                const autocompleteBox = document.getElementById('autocomplete-box');

                let currentPlan = null;
                let openFiles = {};
                let currentFile = null;

                activityBarIcons.forEach(icon => {
                    icon.addEventListener('click', () => {
                        const viewId = icon.dataset.view;
                        activityBarIcons.forEach(i => i.classList.remove('active'));
                        icon.classList.add('active');
                        sidebarViews.forEach(view => {
                            view.classList.toggle('active', view.id === viewId);
                        });
                        sidebarContainer.style.width = viewId === 'preview-view' ? '40%' : '16rem';
                    });
                });

                async function initializeApp() {
                    loginOverlay.style.display = 'none';
                    mainApp.style.display = 'flex';
                    try {
                        const user = await puter.auth.getUser();
                        usernameDisplay.textContent = user.username ? `${user.username}'s Files` : 'Explorer';
                    } catch (error) {
                        console.error("Could not fetch user info:", error);
                        usernameDisplay.textContent = 'Explorer';
                    }
                    refreshFileList();
                    appendChatMessage('ai', 'Hello! How can I help you build something amazing today?');
                }

                signInBtn.addEventListener('click', async () => {
                    try {
                        await puter.auth.signIn();
                        initializeApp();
                    } catch (error) {
                        console.error('Sign-in failed:', error);
                    }
                });

                (async () => {
                    if (await puter.auth.isSignedIn()) {
                        initializeApp();
                    } else {
                        loginOverlay.style.display = 'flex';
                    }
                })();

                function getFileIcon(filename) {
                    const extension = filename.split('.').pop().toLowerCase();
                    switch (extension) {
                        case 'html': return '<i class="fas fa-code file-icon text-red-400"></i>';
                        case 'css': return '<i class="fab fa-css3-alt file-icon text-blue-400"></i>';
                        case 'js': return '<i class="fab fa-js-square file-icon text-yellow-400"></i>';
                        default: return '<i class="fas fa-file file-icon text-gray-400"></i>';
                    }
                }

                async function refreshFileList() {
                    try {
                        const files = await puter.fs.readdir('/');
                        fileList.innerHTML = '';
                        files.forEach(file => {
                            const fileElement = document.createElement('div');
                            fileElement.className = 'p-1 hover:bg-gray-700 cursor-pointer rounded text-sm flex items-center file-item';
                            fileElement.dataset.filename = file.name;
                            fileElement.innerHTML = `${getFileIcon(file.name)}<span>${file.name}</span>`;
                            fileElement.onclick = () => openFile(file.name);
                            fileList.appendChild(fileElement);
                        });
                    } catch (error) {
                        console.error('Error reading directory:', error);
                        appendChatMessage('system', `Error reading directory: ${error.message}`);
                    }
                }

                async function openFile(filename) {
                    if (openFiles[filename]) {
                        switchToFile(filename);
                        return;
                    }
                    try {
                        const content = await puter.fs.read(filename);
                        const blob = new Blob([content]);
                        const text = await blob.text();
                        openFiles[filename] = { content: text };
                        createTab(filename);
                        switchToFile(filename);
                    } catch (error) {
                        console.error(`Error opening file ${filename}:`, error);
                        if (error.code === 'subject_does_not_exist') {
                            appendChatMessage('system', `File "${filename}" not found. Refreshing list.`);
                            await refreshFileList();
                        } else {
                            appendChatMessage('system', `Error opening file: ${error.message}`);
                        }
                    }
                }

                function createTab(filename) {
                    const tab = document.createElement('div');
                    tab.className = 'p-2 cursor-pointer border-b-2 border-transparent text-sm flex items-center';
                    tab.dataset.filename = filename;
                    const label = document.createElement('span');
                    label.textContent = filename;
                    label.onclick = () => switchToFile(filename);
                    const closeIcon = document.createElement('i');
                    closeIcon.className = 'fas fa-times ml-2 p-1 rounded-full hover:bg-gray-700 text-xs';
                    closeIcon.onclick = (e) => {
                        e.stopPropagation();
                        closeFile(filename);
                    };
                    tab.append(label, closeIcon);
                    editorTabs.appendChild(tab);
                }

                function switchToFile(filename) {
                    currentFile = filename;
                    codeEditor.value = openFiles[filename].content;
                    document.querySelectorAll('#editor-tabs > div').forEach(tab => {
                        const isActive = tab.dataset.filename === filename;
                        tab.classList.toggle('border-blue-500', isActive);
                        tab.classList.toggle('text-white', isActive);
                        tab.classList.toggle('bg-editor-bg', isActive);
                        tab.classList.toggle('text-gray-400', !isActive);
                    });
                    // Highlight selected file in explorer
                    document.querySelectorAll('.file-item').forEach(item => {
                        item.classList.toggle('selected-file', item.dataset.filename === filename);
                    });
                    updatePreview();
                }

                function closeFile(filename) {
                    delete openFiles[filename];
                    document.querySelector(`#editor-tabs > div[data-filename="${filename}"]`)?.remove();
                    if (currentFile === filename) {
                        const remainingFiles = Object.keys(openFiles);
                        if (remainingFiles.length > 0) {
                            switchToFile(remainingFiles[0]);
                        } else {
                            currentFile = null;
                            codeEditor.value = '';
                            updatePreview();
                        }
                    }
                }

                createFileBtn.addEventListener('click', async () => {
                    const filename = newFilenameInput.value.trim();
                    if (filename) {
                        try {
                            await puter.fs.write(filename, '');
                            newFilenameInput.value = '';
                            await refreshFileList();
                            appendChatMessage('system', `File "${filename}" created.`);
                            openFile(filename);
                        } catch (error) {
                            console.error('Error creating file:', error);
                            appendChatMessage('system', `Error creating file: ${error.message}`);
                        }
                    }
                });

                codeEditor.addEventListener('input', () => {
                    if (currentFile) {
                        openFiles[currentFile].content = codeEditor.value;
                        updatePreview();
                    }
                });

                function updatePreview() {
                    const htmlFile = Object.keys(openFiles).find(f => f === 'index.html') || Object.keys(openFiles).find(f => f.endsWith('.html'));
                    if (!htmlFile || !openFiles[htmlFile]) {
                        previewIframe.srcdoc = '<html><body><p>Create an index.html file to see a preview.</p></body></html>';
                        return;
                    }
                    let htmlContent = openFiles[htmlFile].content;
                    Object.keys(openFiles).forEach(file => {
                        if (file.endsWith('.css')) {
                            const regex = new RegExp(`<link.*href="${file}".*>`, 'g');
                            htmlContent = htmlContent.replace(regex, `<style>${openFiles[file].content}</style>`);
                        } else if (file.endsWith('.js')) {
                            const regex = new RegExp(`<script.*src="${file}".*><\/script>`, 'g');
                            htmlContent = htmlContent.replace(regex, `<script>${openFiles[file].content}<\/script>`);
                        }
                    });
                    previewIframe.srcdoc = htmlContent;
                }

                function extractAiContent(response) {
                    if (response && response.message && typeof response.message.content === 'string') {
                        return response.message.content;
                    }
                    if (typeof response === 'string') {
                        return response;
                    }
                    console.error("Could not extract content from AI response:", response);
                    return "";
                }

                function extractAndParseJson(response) {
                    const content = extractAiContent(response);
                    if (!content) return null;
                    try {
                        return JSON.parse(content);
                    } catch (e) {
                        const match = content.match(/```json\n([\s\S]*?)\n```/);
                        const jsonText = match ? match[1] : content;
                        try {
                            return JSON.parse(jsonText);
                        } catch (e2) {
                            console.error("JSON parsing failed after extraction:", e2);
                            return null;
                        }
                    }
                }

                async function handleUserChat() {
                    const userInput = chatInput.value.trim();
                    if (!userInput) return;
                    appendChatMessage('user', userInput);
                    chatInput.value = '';
                    const thinkingMessage = appendChatMessage('ai', 'Thinking...', true);
                    try {
                        const prompt = `You are an expert AI developer. The user wants: "${userInput}".
Your task is to generate an execution plan.
YOU MUST RESPOND WITH A VALID JSON OBJECT AND NOTHING ELSE.
The JSON object must have two keys:
1. "plan": A string describing the high-level plan.
2. "todo": An array of strings representing concrete, machine-readable steps.

Each string in the "todo" array MUST follow one of these exact formats:
- 'CREATE_FILE: "filename.ext"'
- 'WRITE_CODE: "filename.ext"'

IMPORTANT: The main HTML file for any web project MUST be named "index.html".

For example, if the user wants a simple webpage, the todo list might be:
["CREATE_FILE: \"index.html\"", "WRITE_CODE: \"index.html\"", "CREATE_FILE: \"style.css\"", "WRITE_CODE: \"style.css\""]

Do not include any explanatory text before or after the JSON object.`;
                        const response = await puter.ai.chat(prompt);
                        
                        if (response && response.finish_reason === 'length') {
                            const thinkingMessageContent = thinkingMessage.querySelector('.message-content');
                            if (thinkingMessageContent) {
                                thinkingMessageContent.textContent = 'Sorry, the AI\'s response was too long and was cut off. Please try a simpler or more specific request.';
                            }
                            return; 
                        }

                        const parsedResponse = extractAndParseJson(response);
                        
                        if (parsedResponse && parsedResponse.plan && Array.isArray(parsedResponse.todo)) {
                            thinkingMessage.remove();
                            currentPlan = parsedResponse;
                            appendPlanToChat(parsedResponse.plan, parsedResponse.todo);
                        } else {
                            console.error("AI response was not in the expected format. Received:", response);
                            const thinkingMessageContent = thinkingMessage.querySelector('.message-content');
                            if (thinkingMessageContent) {
                                thinkingMessageContent.textContent = 'Sorry, I had trouble generating a plan. The AI did not provide a valid response. Please try rephrasing your request.';
                            }
                        }
                    } catch (error) {
                        console.error('AI chat error:', error);
                        const thinkingMessageContent = thinkingMessage.querySelector('.message-content');
                        if(thinkingMessageContent) {
                            if (error && error.error && error.error.delegate === 'usage-limited-chat') {
                                thinkingMessageContent.textContent = 'It looks like you\'ve hit the usage limit for the AI service. Please try again later.';
                            } else {
                                thinkingMessageContent.textContent = 'An unexpected error occurred while communicating with the AI. Please try again.';
                            }
                        }
                    }
                }
                
                sendChatBtn.addEventListener('click', handleUserChat);
                chatInput.addEventListener('keypress', (e) => e.key === 'Enter' && handleUserChat());

                function appendChatMessage(sender, message, isLoading = false) {
                    const messageElement = document.createElement('div');
                    const senderClasses = {
                        user: 'bg-blue-600 self-end',
                        system: 'bg-gray-600 italic text-center w-full',
                        ai: 'bg-gray-800 self-start'
                    };
                    messageElement.className = `message mb-2 p-3 rounded text-sm max-w-md ${senderClasses[sender]}`;
                    const senderElement = document.createElement('div');
                    senderElement.className = 'font-bold text-xs mb-1 capitalize';
                    senderElement.textContent = sender;
                    const contentElement = document.createElement('div');
                    contentElement.className = 'message-content';
                    contentElement.innerHTML = isLoading ? `<i class="fas fa-spinner fa-spin mr-2"></i>${message}` : message;
                    if (sender !== 'system') messageElement.append(senderElement);
                    messageElement.append(contentElement);
                    chatHistory.appendChild(messageElement);
                    chatHistory.scrollTop = chatHistory.scrollHeight;
                    return messageElement;
                }

                chatHistory.addEventListener('click', (event) => {
                    const target = event.target;
                    if (target.classList.contains('approve-btn')) {
                        if (!currentPlan) return appendChatMessage('system', 'There is no active plan to approve.');
                        appendChatMessage('system', 'Plan approved. Executing tasks...');
                        executePlan();
                        target.parentElement.innerHTML = '<span class="text-xs text-green-400">Plan Approved & Executing...</span>';
                    }
                    if (target.classList.contains('request-changes-btn')) {
                        appendChatMessage('user', 'I would like to request changes to the plan.');
                        chatInput.focus();
                        target.parentElement.innerHTML = '<span class="text-xs text-yellow-400">Changes Requested.</span>';
                    }
                });

                function appendPlanToChat(plan, todo) {
                    const planHtml = `
                        <div class="p-2 border-b border-gray-700">
                            <h4 class="font-bold text-sm mb-2">Execution Plan:</h4>
                            <p class="text-xs">${plan}</p>
                        </div>
                        <div class="p-2">
                            <h4 class="font-bold text-sm mb-2">To-Do List:</h4>
                            <ul class="list-disc list-inside text-xs">
                                ${todo.map(task => `<li>${task}</li>`).join('')}
                            </ul>
                        </div>
                        <div class="chat-plan-buttons flex justify-end space-x-2 p-2 border-t border-gray-700 mt-2">
                            <button class="approve-btn bg-green-600 hover:bg-green-700 text-white font-bold py-1 px-3 rounded text-xs">Approve Plan</button>
                            <button class="request-changes-btn bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-1 px-3 rounded text-xs">Request Changes</button>
                        </div>
                    `;
                    appendChatMessage('ai', planHtml);
                }

                /**
                 * NEW: Simulates a typing effect in a textarea.
                 * @param {string} text The text to type.
                 * @param {HTMLTextAreaElement} element The textarea element to type into.
                 * @param {number} speed The delay between characters in milliseconds.
                 */
                function typeCode(text, element, speed = 10) {
                    return new Promise(resolve => {
                        let i = 0;
                        element.value = '';
                        element.disabled = true;
                        
                        function typing() {
                            if (i < text.length) {
                                element.value += text.charAt(i);
                                i++;
                                setTimeout(typing, speed);
                            } else {
                                element.disabled = false;
                                element.dispatchEvent(new Event('input')); // Trigger input event for preview
                                resolve();
                            }
                        }
                        typing();
                    });
                }

                async function executePlan() {
                    if (!currentPlan?.todo) return;
                    for (let i = 0; i < currentPlan.todo.length; i++) {
                        const task = currentPlan.todo[i];
                        appendChatMessage('system', `Executing: ${task}`);
                        try {
                            const [action, ...rest] = task.split(':');
                            const pathPart = rest.join(':').trim();
                            const filenameMatch = pathPart.match(/"([^"]+)"/);

                            if (!filenameMatch) {
                                console.warn(`Could not parse filename from task: "${task}". Skipping.`);
                                continue;
                            }
                            const filename = filenameMatch[1];
                            const trimmedAction = action.trim();

                            if (trimmedAction === 'CREATE_FILE') {
                                appendChatMessage('system', `Creating file: ${filename}`);
                                await puter.fs.write(filename, '');
                                await refreshFileList();
                                await openFile(filename);
                            } else if (trimmedAction === 'WRITE_CODE') {
                                appendChatMessage('system', `Generating code for: ${filename}`);
                                const codePrompt = `Generate the complete code for the file "${filename}" based on the overall plan: "${currentPlan.plan}". IMPORTANT: Only output the raw code itself, with absolutely no explanations, comments about the code, or markdown formatting.`;
                                
                                const codeResponse = await puter.ai.chat(codePrompt);
                                let finalCode = extractAiContent(codeResponse);
                                
                                const codeMatch = finalCode.match(/```(?:\w*\n)?([\s\S]*?)```/);
                                if (codeMatch && codeMatch[1]) {
                                    finalCode = codeMatch[1].trim();
                                } else {
                                    finalCode = finalCode.trim();
                                }

                                appendChatMessage('system', `Writing code to: ${filename}`);
                                await puter.fs.write(filename, finalCode);
                                
                                if (openFiles[filename]) {
                                    openFiles[filename].content = finalCode;
                                } else {
                                    await openFile(filename);
                                }
                                
                                if (currentFile === filename) {
                                    // Use the new typing effect
                                    await typeCode(finalCode, codeEditor);
                                }
                            }
                            updatePreview();
                        } catch (error) {
                            console.error(`Error executing task "${task}":`, error);
                            appendChatMessage('system', `Error on task "${task}": ${error.message}`);
                            break;
                        }
                    }
                    appendChatMessage('system', 'All tasks completed!');
                    currentPlan = null;
                }

                publishBtn.addEventListener('click', async () => {
                    appendChatMessage('system', 'Publishing website...');
                    try {
                        for (const filename in openFiles) {
                            await puter.fs.write(filename, openFiles[filename].content);
                        }
                        const dirName = 'published-site';
                        try { await puter.fs.rm(dirName, { recursive: true }); } catch (e) { /* Ignore */ }
                        await puter.fs.mkdir(dirName);
                        const files = await puter.fs.readdir('/');
                        for (const file of files) {
                            if (!file.isDir) {
                                try {
                                    const content = await puter.fs.read(file.name);
                                    await puter.fs.write(`${dirName}/${file.name}`, content);
                                } catch (readError) {
                                    console.warn(`Could not read file "${file.name}" during publish. Skipping.`, readError);
                                }
                            }
                        }
                        const subdomain = puter.randName();
                        const site = await puter.hosting.create(subdomain, dirName);
                        const url = `https://${site.subdomain}.puter.site`;
                        appendChatMessage('system', `Website published at: <a href="${url}" target="_blank" class="text-blue-400 underline">${url}</a>`);
                    } catch (error) {
                        console.error('Publishing error:', error);
                        appendChatMessage('system', `Publishing failed: ${error.message}`);
                    }
                });

                // --- NEW: Autocomplete Logic ---
                const htmlSuggestions = ['<!DOCTYPE html>', '<html>', '<head>', '<title>', '<body>', '<h1>', '<h2>', '<p>', '<div>', '<span>', '<img>', '<a>', '<script>', '<style>', '<ul>', '<ol>', '<li>'];
                const cssSuggestions = ['color', 'background-color', 'font-size', 'font-family', 'width', 'height', 'padding', 'margin', 'border', 'display', 'position'];
                let currentSuggestions = [];
                let selectedSuggestionIndex = -1;

                function showAutocomplete(suggestions) {
                    if (suggestions.length === 0) {
                        hideAutocomplete();
                        return;
                    }
                    autocompleteBox.innerHTML = '';
                    suggestions.forEach((suggestion, index) => {
                        const item = document.createElement('div');
                        item.className = 'autocomplete-item';
                        item.textContent = suggestion;
                        item.addEventListener('click', () => {
                            insertSuggestion(suggestion);
                            hideAutocomplete();
                        });
                        autocompleteBox.appendChild(item);
                    });
                    
                    const rect = codeEditor.getBoundingClientRect();
                    const caretPos = getCaretCoordinates(codeEditor, codeEditor.selectionEnd);
                    autocompleteBox.style.display = 'block';
                    autocompleteBox.style.left = `${rect.left + caretPos.x}px`;
                    autocompleteBox.style.top = `${rect.top + caretPos.y + 20}px`;
                    selectedSuggestionIndex = -1;
                }

                function hideAutocomplete() {
                    autocompleteBox.style.display = 'none';
                }

                function insertSuggestion(suggestion) {
                    const text = codeEditor.value;
                    const cursorPos = codeEditor.selectionStart;
                    const textBefore = text.substring(0, cursorPos);
                    const wordStart = textBefore.lastIndexOf('<') > textBefore.lastIndexOf(' ') ? textBefore.lastIndexOf('<') : textBefore.lastIndexOf(' ') + 1;
                    
                    const newText = text.substring(0, wordStart) + suggestion + text.substring(cursorPos);
                    codeEditor.value = newText;
                    codeEditor.focus();
                    codeEditor.selectionStart = codeEditor.selectionEnd = wordStart + suggestion.length;
                }

                codeEditor.addEventListener('input', () => {
                    const text = codeEditor.value;
                    const cursorPos = codeEditor.selectionStart;
                    const textBefore = text.substring(0, cursorPos);
                    const currentWord = textBefore.split(/[\s<]/).pop();

                    if (currentWord.length > 0) {
                        const suggestions = (currentFile && currentFile.endsWith('.css') ? cssSuggestions : htmlSuggestions)
                            .filter(s => s.startsWith(currentWord.toLowerCase()));
                        currentSuggestions = suggestions;
                        showAutocomplete(suggestions);
                    } else {
                        hideAutocomplete();
                    }
                });

                codeEditor.addEventListener('keydown', (e) => {
                    if (autocompleteBox.style.display === 'none') return;

                    if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        selectedSuggestionIndex = (selectedSuggestionIndex + 1) % currentSuggestions.length;
                        updateSelectedSuggestion();
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        selectedSuggestionIndex = (selectedSuggestionIndex - 1 + currentSuggestions.length) % currentSuggestions.length;
                        updateSelectedSuggestion();
                    } else if (e.key === 'Enter' && selectedSuggestionIndex > -1) {
                        e.preventDefault();
                        insertSuggestion(currentSuggestions[selectedSuggestionIndex]);
                        hideAutocomplete();
                    } else if (e.key === 'Escape') {
                        hideAutocomplete();
                    }
                });

                function updateSelectedSuggestion() {
                    const items = autocompleteBox.querySelectorAll('.autocomplete-item');
                    items.forEach((item, index) => {
                        item.classList.toggle('selected', index === selectedSuggestionIndex);
                    });
                }

                // Helper to get cursor position
                function getCaretCoordinates(element, position) {
                    const mirrorDiv = document.createElement('div');
                    document.body.appendChild(mirrorDiv);
                    const style = window.getComputedStyle(element);
                    ['fontFamily', 'fontSize', 'fontWeight', 'fontStyle', 'letterSpacing', 'textTransform', 'wordSpacing', 'lineHeight', 'padding'].forEach(prop => {
                        mirrorDiv.style[prop] = style[prop];
                    });
                    mirrorDiv.style.position = 'absolute';
                    mirrorDiv.style.visibility = 'hidden';
                    mirrorDiv.style.whiteSpace = 'pre-wrap';
                    mirrorDiv.style.wordWrap = 'break-word';
                    mirrorDiv.style.width = element.clientWidth + 'px';
                    mirrorDiv.textContent = element.value.substring(0, position);
                    const span = document.createElement('span');
                    span.textContent = element.value.substring(position) || '.';
                    mirrorDiv.appendChild(span);
                    const coords = { x: span.offsetLeft, y: span.offsetTop };
                    document.body.removeChild(mirrorDiv);
                    return coords;
                }


            } catch (e) {
                console.error('A critical error occurred during initialization:', e);
                document.body.innerHTML = `<div style="font-family: sans-serif; color: #ff4d4d; background-color: #1e1e1e; height: 100vh; display: flex; align-items: center; justify-content: center; padding: 2rem;"><div><h2 style="font-size: 1.5rem; margin-bottom: 1rem;">Application Error</h2><p>A critical error prevented the app from starting. Please check the developer console for details.</p><p style="margin-top: 1rem; font-family: monospace; background: #333; padding: 1rem; border-radius: 5px;">Error: ${e.message}</p></div></div>`;
            }
        });
    </script>
</body>
</html>
